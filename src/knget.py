#!/usr/bin/env python3
# coding: utf-8

import os
import re
import sys
import json
import time
import copy
import random
import requests

_NO_ERROR = 0
_CONFIG_ERROR = 1
_USAGE_ERROR = 2
_CONNECT_ERROR = 3
_DOWNLOAD_ERROR = 4

_USAGE = '''\
Usage: {0} <tags> <[begin]<end>>
'''.format(sys.argv[0])

_CONFIG_TIPS = '''\
; KngetPy Project.
; File auto-generated by {0}
;
; Edit the base_url in the custom section
; to download different kind of images on site.
;
; Project links:
;   https://github.com/urain39/KngetPy
;   https://github.com/urain39/IniFilePy
;
'''.format(sys.argv[0])

_DEFAUL_CONFIG = {
    'custom': {
        'base_url': 'https://konachan.net',
        'page_limit': 10,
        'user_agent': 'Mozilla/5.0(Macintosh;U;IntelMacOSX10_6_8;en-us)AppleWebKit/534.50(KHTML,likeGecko)Version/5.1Safari/534.50',
        'load_time_fake': '0-1'
    },
    'download': {
        'debug': 0,
        'thread': 8,
        'timeout': 10,
        'maxsize': 10,
        'bufsize': 1048576,
        'retry_wait': 8,
        'retry_count': 3
    }
}

_DIGITS = "0123456789"
_DEFAULT_SECTION = '0x22CAFE!'

class IniException(Exception):
    pass


class IniFile():
    def __init__(self, filename=None):
        self._filename = filename
        self._section = _DEFAULT_SECTION

        self._props = {
            self._section: {}
        }

        if self._filename is not None:
            self._parser()

    def _parser(self):
        if not os.path.exists(self._filename):
            raise IniException('Not found file named as [%s]' % self._filename)

        with open(self._filename, 'r') as _file:
            for _line in _file.readlines():
                _line = _line.strip()                   # No blank
                _line = _line.strip('\n')               # No newline

                if _line  == '' or _line[0] in (';', '#'):
                    continue                            # Skip comment or blank
                elif _line[0] == '[':
                    if _line[-1] != ']':
                        raise IniException('No closed section!')

                    self._section = _line[1:-1]         # Update section

                    if self._section == '':
                        raise IniException('Section is empty!')

                    if self._props.get(self._section) is None:
                        self._props.setdefault(self._section, {})
                    continue
                else:
                    if not '=' in _line:
                        raise IniException('SyntaxError at [%s]' % _line)

                    for i in range(len(_line)):
                        if _line[i] == '=':
                            key = _line[:i].strip()
                            value = _line[i+1:].strip()

                            # XXX: I know it's not a good way,
                            #    : But it's better to read isn't is?
                            if all([i in _DIGITS for i in value] or [None]):
                                self._props[self._section][key] = int(value)
                            else:
                                self._props[self._section][key] = str(value)
                            break

    def get(self, key, section=None):
        section = section or self._section

        if self._props.get(section) is None:
            raise IniException('Section is empty!')

        return copy.deepcopy(self._props[section].get(key))

    def add(self, key, value, section=None):
        section = section or self._section

        if self._props.get(section) is None:
            self._props.setdefault(section, {})

        self._props[section][key] = value

    def delete(self, key, section=None):
        section = section or self._section

        if self._props.get(section) is None:
            return

        if self._props[section].get(key) is not None:
            del self._props[section][key]

        if len(self._props[section]) == 0:
            del self._props[section]

    def dump(self, fp=sys.stdout):
        for section in self._props.keys():
            if section != _DEFAULT_SECTION:
                fp.write("[%s]\n" % section)

            for key in self._props[section].keys():
                fp.write("%s=%s\n" % (key, self._props[section][key]))

    def get_section(self, section=None):
        section = section or self._section

        if self._props.get(section) is None:
            raise IniException('Section is empty!')

        return copy.deepcopy(self._props[section])

    def reset(self, props=None):
        self._props = copy.deepcopy(props)

    def section(self, section=None):
        section = section or self._section

        self._section = section


class KngetError():
    pass


class Knget():
    def __init__(self, config):
        self._tags = []
        self._curdir = os.getcwd()
        self._custom = config.get_section('custom')
        self._config = config.get_section('download')
        self._session = requests.Session()
        self._session.headers = {
                'Accept': '*/*',
                'Connection': 'Keep-Alive',
                'User-Agent': self._custom.get('user_agent'),
                'Referer': self._custom.get('base_url') + '/post/'
        }
        self._task_pool = dict()
        self._meta_infos = list()

    def _load_faker(self):
        load_time_fake = [
            int(i) for i in (
                self._custom.get('load_time_fake') or '1-3'
            ).split('-')[:2]
        ]

        load_time = random.randint(*load_time_fake) + random.random()

        self._msg2("Load time: %0.2f" % load_time)
        time.sleep(load_time)

    def _msg(self, msg):
        sys.stderr.write('=> {0}\n'.format(msg))

    def _msg2(self, msg):
        sys.stderr.write('    => {0}\n'.format(msg))

    def _chdir(self, tags):
            save_dir = 'kn-' + '-'.join(
                tags.split()
            )

            if not os.path.exists(save_dir):
                if os.path.isfile(save_dir):
                    os.remove(save_dir)
                os.mkdir(save_dir)
            os.chdir(save_dir)

    def _check_url(self, url):
        protocol = re.match(r'((?:ht|f)tps?:).*', url)

        if protocol is None:
            # 从base_url获取协议头
            base_url = self._custom.get('base_url')
            return re.match(r'((?:ht|f)tps?:).*', base_url).group(1) + url

        return url

    def _download(self, job):
        url =  job['file_url']
        file_size = job['file_size']
        file_name = '{post_id}.{file_ext}'.format(
            post_id=job['id'],
            # 使用较保守的方法获取扩展名
            file_ext=job['file_url'].split('.')[-1]
        )

        file_name = file_name.split('?')[0]

        response = self._session.get(
            url=self._check_url(url),
            stream=True,
            timeout=self._config.get('timeout') or 10
        )

        self._load_faker()
        if not os.path.exists(file_name) or os.path.getsize(file_name) != file_size:
            with open(file_name, 'wb') as fp:
                bufsize = self._config.get('bufsize') or (1<<20)

                for data in response.iter_content(chunk_size=bufsize):
                    fp.write(data)

    def _cleanup(self):
        with open('meta_data.json', 'w') as fp:
            json.dump(self._meta_infos, fp)

        os.chdir(self._curdir)
        for _dir in os.listdir(self._curdir):
            if os.path.isdir(_dir) and len(os.listdir(_dir)) < 1:
                os.rmdir(_dir)
                self._msg2('save_dir {0} is empty, removed.'.format(_dir))

    def _filter(self):
        post_rating = self._custom.get('post_rating')
        post_min_score = self._custom.get('post_min_score')
        post_tags_blacklist = self._custom.get('post_tags_blacklist')

        if post_rating != r'' and post_rating != None:
            self._task_pool = [
                task
                for task in self._task_pool
                    if task.get('rating') in post_rating.split()
            ]

        if post_min_score != r'' and post_min_score != None:
            self._task_pool = [
                task
                for task in self._task_pool
                    if (task.get('score') or task.get('total_score' or 0)) >= post_min_score
            ]

        if post_tags_blacklist != r'' and post_tags_blacklist != None:
            self._task_pool = [
                task
                for task in self._task_pool
                    if all([tag not in post_tags_blacklist.split() for tag in task['tags'].split()])
            ]

    def work(self):
        self._filter()

        jobs_count = len(self._task_pool)
        retry_count = self._config.get('retry_count')
        retry_wait = self._config.get('retry_wait')

        cur_jobs_count = 0
        cur_retry_count = 0

        self._meta_infos.extend(self._task_pool)

        for job in self._task_pool:
            file_size = job.get('file_size')

            if (file_size or 0) < self._config.get('maxsize') * (1<<20):
                cur_jobs_count += 1
                cur_retry_count = 0

                while True:
                    try:
                        self._msg2('Process: %4d / %-4d' % (cur_jobs_count, jobs_count))

                        self._download(job)
                        break
                    except requests.exceptions.RequestException as e:
                        if cur_retry_count < retry_count:
                            self._msg2('Error: {0}'.format(e))
                            self._msg2('wait {0}s...'.format(retry_wait))
                            time.sleep(retry_wait)
                            cur_retry_count += 1
                            continue
                        else:
                            self._cleanup()
                            sys.exit(_DOWNLOAD_ERROR)

    def run(self, tags, begin, end):
        self._chdir(tags)
        self._tags = tags

        for page in range(begin, end + 1):
            self._load_faker()
            self._msg('[Page = {0} | tags = {1}]'.format(page, tags))

            payload = {
                    'page': page,
                    'tags': tags,
                    'limit': self._custom.get('page_limit')
            }

            response = self._session.get(
                self._custom.get('base_url') + '/post/index.json',
                timeout=self._config.get('timeout'),
                params=payload
            )

            self._task_pool = response.json()

            if len(self._task_pool) < 1:
                break
            elif len(self._task_pool) < self._custom.get('page_limit'):
                self.work()
                break
            else:
                self.work()
        self._cleanup()


def usage(status=None):
    print(_USAGE)

    if status is None:
        return
    else:
        sys.exit(status)

def main(argv):
    if os.path.exists('config.ini'):
        try:
            config = IniFile('config.ini')
        except IniException as e:
            print('{0}\n'.format(e))
            print('Possible cannot read?')
            sys.exit(_CONFIG_ERROR)
    else:
        with open('config.ini', 'w') as fp:
            config = IniFile()
            config.reset(_DEFAUL_CONFIG)
            fp.write(_CONFIG_TIPS + '\n')
            config.dump(fp)

    knget = Knget(config)

    if len(argv) < 3:
        return usage(_USAGE_ERROR)
    elif len(argv) == 3:
        knget.run(argv[1], 1 ,int(argv[2]))
    elif len(argv) == 4:
        knget.run(argv[1], int(argv[2]), int(argv[3]))
    else:
        return usage(_USAGE_ERROR)

if __name__ == '__main__':
    try:
        main(sys.argv)
    except KeyboardInterrupt:
        sys.exit(_NO_ERROR)
